# coding: utf-8

"""
    CyberSource Merged Spec

    All CyberSource API specs merged together. These are available at https://developer.cybersource.com/api/reference/api-reference.html

    OpenAPI spec version: 0.0.1
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

from pprint import pformat
from six import iteritems
import re


class GenerateUnifiedCheckoutCaptureContextRequest(object):
    """
    NOTE: This class is auto generated by the swagger code generator program.
    Do not edit the class manually.
    """


    """
    Attributes:
      swagger_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    swagger_types = {
        'client_version': 'str',
        'target_origins': 'list[str]',
        'allowed_card_networks': 'list[str]',
        'allowed_payment_types': 'list[str]',
        'country': 'str',
        'locale': 'str',
        'button_type': 'str',
        'capture_mandate': 'Upv1capturecontextsCaptureMandate',
        'complete_mandate': 'Upv1capturecontextsCompleteMandate',
        'transient_token_response_options': 'Microformv2sessionsTransientTokenResponseOptions',
        'data': 'Upv1capturecontextsData',
        'order_information': 'Upv1capturecontextsOrderInformation'
    }

    attribute_map = {
        'client_version': 'clientVersion',
        'target_origins': 'targetOrigins',
        'allowed_card_networks': 'allowedCardNetworks',
        'allowed_payment_types': 'allowedPaymentTypes',
        'country': 'country',
        'locale': 'locale',
        'button_type': 'buttonType',
        'capture_mandate': 'captureMandate',
        'complete_mandate': 'completeMandate',
        'transient_token_response_options': 'transientTokenResponseOptions',
        'data': 'data',
        'order_information': 'orderInformation'
    }

    def __init__(self, client_version=None, target_origins=None, allowed_card_networks=None, allowed_payment_types=None, country=None, locale=None, button_type=None, capture_mandate=None, complete_mandate=None, transient_token_response_options=None, data=None, order_information=None):
        """
        GenerateUnifiedCheckoutCaptureContextRequest - a model defined in Swagger
        """

        self._client_version = None
        self._target_origins = None
        self._allowed_card_networks = None
        self._allowed_payment_types = None
        self._country = None
        self._locale = None
        self._button_type = None
        self._capture_mandate = None
        self._complete_mandate = None
        self._transient_token_response_options = None
        self._data = None
        self._order_information = None

        if client_version is not None:
          self.client_version = client_version
        if target_origins is not None:
          self.target_origins = target_origins
        if allowed_card_networks is not None:
          self.allowed_card_networks = allowed_card_networks
        if allowed_payment_types is not None:
          self.allowed_payment_types = allowed_payment_types
        if country is not None:
          self.country = country
        if locale is not None:
          self.locale = locale
        if button_type is not None:
          self.button_type = button_type
        if capture_mandate is not None:
          self.capture_mandate = capture_mandate
        if complete_mandate is not None:
          self.complete_mandate = complete_mandate
        if transient_token_response_options is not None:
          self.transient_token_response_options = transient_token_response_options
        if data is not None:
          self.data = data
        if order_information is not None:
          self.order_information = order_information

    @property
    def client_version(self):
        """
        Gets the client_version of this GenerateUnifiedCheckoutCaptureContextRequest.
        Specify the version of Unified Checkout that you want to use.

        :return: The client_version of this GenerateUnifiedCheckoutCaptureContextRequest.
        :rtype: str
        """
        return self._client_version

    @client_version.setter
    def client_version(self, client_version):
        """
        Sets the client_version of this GenerateUnifiedCheckoutCaptureContextRequest.
        Specify the version of Unified Checkout that you want to use.

        :param client_version: The client_version of this GenerateUnifiedCheckoutCaptureContextRequest.
        :type: str
        """

        self._client_version = client_version

    @property
    def target_origins(self):
        """
        Gets the target_origins of this GenerateUnifiedCheckoutCaptureContextRequest.
        The [target origin](https://developer.mozilla.org/en-US/docs/Glossary/Origin) of the website on which you will be launching Unified Checkout is defined by the scheme (protocol), hostname (domain) and port number (if used).    You must use https://hostname (unless you use http://localhost) Wildcards are NOT supported.  Ensure that subdomains are included. Any valid top-level domain is supported (e.g. .com, .co.uk, .gov.br etc)  Examples:   - https://example.com   - https://subdomain.example.com   - https://example.com:8080<br><br>  If you are embedding within multiple nested iframes you need to specify the origins of all the browser contexts used, for example:    targetOrigins: [     \"https://example.com\",     \"https://basket.example.com\",     \"https://ecom.example.com\"   ] 

        :return: The target_origins of this GenerateUnifiedCheckoutCaptureContextRequest.
        :rtype: list[str]
        """
        return self._target_origins

    @target_origins.setter
    def target_origins(self, target_origins):
        """
        Sets the target_origins of this GenerateUnifiedCheckoutCaptureContextRequest.
        The [target origin](https://developer.mozilla.org/en-US/docs/Glossary/Origin) of the website on which you will be launching Unified Checkout is defined by the scheme (protocol), hostname (domain) and port number (if used).    You must use https://hostname (unless you use http://localhost) Wildcards are NOT supported.  Ensure that subdomains are included. Any valid top-level domain is supported (e.g. .com, .co.uk, .gov.br etc)  Examples:   - https://example.com   - https://subdomain.example.com   - https://example.com:8080<br><br>  If you are embedding within multiple nested iframes you need to specify the origins of all the browser contexts used, for example:    targetOrigins: [     \"https://example.com\",     \"https://basket.example.com\",     \"https://ecom.example.com\"   ] 

        :param target_origins: The target_origins of this GenerateUnifiedCheckoutCaptureContextRequest.
        :type: list[str]
        """

        self._target_origins = target_origins

    @property
    def allowed_card_networks(self):
        """
        Gets the allowed_card_networks of this GenerateUnifiedCheckoutCaptureContextRequest.
        The list of card networks you want to use for this Unified Checkout transaction.  Unified Checkout currently supports the following card networks:     - VISA     - MASTERCARD     - AMEX     - CARNET     - CARTESBANCAIRES     - CUP     - DINERSCLUB     - DISCOVER     - EFTPOS     - ELO     - JAYWAN     - JCB     - JCREW     - KCP     - MADA     - MAESTRO     - MEEZA     - PAYPAK     - UATP 

        :return: The allowed_card_networks of this GenerateUnifiedCheckoutCaptureContextRequest.
        :rtype: list[str]
        """
        return self._allowed_card_networks

    @allowed_card_networks.setter
    def allowed_card_networks(self, allowed_card_networks):
        """
        Sets the allowed_card_networks of this GenerateUnifiedCheckoutCaptureContextRequest.
        The list of card networks you want to use for this Unified Checkout transaction.  Unified Checkout currently supports the following card networks:     - VISA     - MASTERCARD     - AMEX     - CARNET     - CARTESBANCAIRES     - CUP     - DINERSCLUB     - DISCOVER     - EFTPOS     - ELO     - JAYWAN     - JCB     - JCREW     - KCP     - MADA     - MAESTRO     - MEEZA     - PAYPAK     - UATP 

        :param allowed_card_networks: The allowed_card_networks of this GenerateUnifiedCheckoutCaptureContextRequest.
        :type: list[str]
        """

        self._allowed_card_networks = allowed_card_networks

    @property
    def allowed_payment_types(self):
        """
        Gets the allowed_payment_types of this GenerateUnifiedCheckoutCaptureContextRequest.
        The payment types that are allowed for the merchant.    Possible values when launching Unified Checkout:   - APPLEPAY   - CHECK   - CLICKTOPAY   - GOOGLEPAY   - PANENTRY                 - PAZE <br><br>  Unified Checkout supports the following Buy Now, Pay Later (BNPL) payment methods:   - AFTERPAY<br><br>  Unified Checkout supports the following Online Bank Transfer payment methods:   - Bancontact (BE)   - DragonPay (PH)   - iDEAL (NL)   - Multibanco (PT)   - MyBank (IT, BE, PT, ES)   - Przelewy24|P24 (PL)   - Tink Pay By Bank (GB)<br><br>    Unified Checkout supports the following Post-Pay Reference payment methods:   - Konbini (JP)<br><br>  Possible values when launching Click To Pay Drop-In UI: - CLICKTOPAY <br><br>  **Important:**    - CLICKTOPAY only available for Visa, Mastercard and AMEX for saved cards.   - Visa and Mastercard will look to tokenize using network tokenization for all Click to Pay requests.  Click to Pay uses Click to Pay token requester IDs and not the merchant's existing token requester.   - Apple Pay, Google Pay, Check, and Paze can be used independently without requiring PAN entry in the allowedPaymentTypes field.<br><br>  **Managing Google Pay Authentication Types** When you enable Google Pay on Unified Checkout you can specify optional parameters that define the types of card authentication you receive from Google Pay.<br><br>  **Managing Google Pay Authentication Types** Where Click to Pay is the payment type selected by the customer and the customer manually enters their card, the option to enroll their card in Click to Pay will be auto-checked if this field is set to \"true\".   This is only available where the merchant and cardholder are based in the following countries and the billing type is set to \"FULL\" or \"PARTIAL\".   - UAE   - Argentina   - Brazil   - Chile   - Colombia   - Kuwait   - Mexico   - Peru   - Qatar   - Saudi Arabia   - Ukraine   - South Africa<br><br>  If false, this is not present or not supported in the market.  Enrollment in Click to Pay is not checked for the customer when completing manual card entry. 

        :return: The allowed_payment_types of this GenerateUnifiedCheckoutCaptureContextRequest.
        :rtype: list[str]
        """
        return self._allowed_payment_types

    @allowed_payment_types.setter
    def allowed_payment_types(self, allowed_payment_types):
        """
        Sets the allowed_payment_types of this GenerateUnifiedCheckoutCaptureContextRequest.
        The payment types that are allowed for the merchant.    Possible values when launching Unified Checkout:   - APPLEPAY   - CHECK   - CLICKTOPAY   - GOOGLEPAY   - PANENTRY                 - PAZE <br><br>  Unified Checkout supports the following Buy Now, Pay Later (BNPL) payment methods:   - AFTERPAY<br><br>  Unified Checkout supports the following Online Bank Transfer payment methods:   - Bancontact (BE)   - DragonPay (PH)   - iDEAL (NL)   - Multibanco (PT)   - MyBank (IT, BE, PT, ES)   - Przelewy24|P24 (PL)   - Tink Pay By Bank (GB)<br><br>    Unified Checkout supports the following Post-Pay Reference payment methods:   - Konbini (JP)<br><br>  Possible values when launching Click To Pay Drop-In UI: - CLICKTOPAY <br><br>  **Important:**    - CLICKTOPAY only available for Visa, Mastercard and AMEX for saved cards.   - Visa and Mastercard will look to tokenize using network tokenization for all Click to Pay requests.  Click to Pay uses Click to Pay token requester IDs and not the merchant's existing token requester.   - Apple Pay, Google Pay, Check, and Paze can be used independently without requiring PAN entry in the allowedPaymentTypes field.<br><br>  **Managing Google Pay Authentication Types** When you enable Google Pay on Unified Checkout you can specify optional parameters that define the types of card authentication you receive from Google Pay.<br><br>  **Managing Google Pay Authentication Types** Where Click to Pay is the payment type selected by the customer and the customer manually enters their card, the option to enroll their card in Click to Pay will be auto-checked if this field is set to \"true\".   This is only available where the merchant and cardholder are based in the following countries and the billing type is set to \"FULL\" or \"PARTIAL\".   - UAE   - Argentina   - Brazil   - Chile   - Colombia   - Kuwait   - Mexico   - Peru   - Qatar   - Saudi Arabia   - Ukraine   - South Africa<br><br>  If false, this is not present or not supported in the market.  Enrollment in Click to Pay is not checked for the customer when completing manual card entry. 

        :param allowed_payment_types: The allowed_payment_types of this GenerateUnifiedCheckoutCaptureContextRequest.
        :type: list[str]
        """

        self._allowed_payment_types = allowed_payment_types

    @property
    def country(self):
        """
        Gets the country of this GenerateUnifiedCheckoutCaptureContextRequest.
        Country the purchase is originating from (e.g. country of the merchant).  Use the two-character ISO Standard 

        :return: The country of this GenerateUnifiedCheckoutCaptureContextRequest.
        :rtype: str
        """
        return self._country

    @country.setter
    def country(self, country):
        """
        Sets the country of this GenerateUnifiedCheckoutCaptureContextRequest.
        Country the purchase is originating from (e.g. country of the merchant).  Use the two-character ISO Standard 

        :param country: The country of this GenerateUnifiedCheckoutCaptureContextRequest.
        :type: str
        """

        self._country = country

    @property
    def locale(self):
        """
        Gets the locale of this GenerateUnifiedCheckoutCaptureContextRequest.
        Localization of the User experience conforming to the ISO 639-1 language standards and two-character ISO Standard Country Code.  Please refer to list of [supported locales through Unified Checkout](https://developer.cybersource.com/docs/cybs/en-us/unified-checkout/developer/all/rest/unified-checkout/uc-appendix-languages.html) 

        :return: The locale of this GenerateUnifiedCheckoutCaptureContextRequest.
        :rtype: str
        """
        return self._locale

    @locale.setter
    def locale(self, locale):
        """
        Sets the locale of this GenerateUnifiedCheckoutCaptureContextRequest.
        Localization of the User experience conforming to the ISO 639-1 language standards and two-character ISO Standard Country Code.  Please refer to list of [supported locales through Unified Checkout](https://developer.cybersource.com/docs/cybs/en-us/unified-checkout/developer/all/rest/unified-checkout/uc-appendix-languages.html) 

        :param locale: The locale of this GenerateUnifiedCheckoutCaptureContextRequest.
        :type: str
        """

        self._locale = locale

    @property
    def button_type(self):
        """
        Gets the button_type of this GenerateUnifiedCheckoutCaptureContextRequest.
        Changes the label on the payment button within Unified Checkout .<br><br>  Possible values: - ADD_CARD - CARD_PAYMENT - CHECKOUT - CHECKOUT_AND_CONTINUE - DEBIT_CREDIT - DONATE - PAY - PAY_WITH_CARD - SAVE_CARD - SUBSCRIBE_WITH_CARD<br><br>  This is an optional field, 

        :return: The button_type of this GenerateUnifiedCheckoutCaptureContextRequest.
        :rtype: str
        """
        return self._button_type

    @button_type.setter
    def button_type(self, button_type):
        """
        Sets the button_type of this GenerateUnifiedCheckoutCaptureContextRequest.
        Changes the label on the payment button within Unified Checkout .<br><br>  Possible values: - ADD_CARD - CARD_PAYMENT - CHECKOUT - CHECKOUT_AND_CONTINUE - DEBIT_CREDIT - DONATE - PAY - PAY_WITH_CARD - SAVE_CARD - SUBSCRIBE_WITH_CARD<br><br>  This is an optional field, 

        :param button_type: The button_type of this GenerateUnifiedCheckoutCaptureContextRequest.
        :type: str
        """

        self._button_type = button_type

    @property
    def capture_mandate(self):
        """
        Gets the capture_mandate of this GenerateUnifiedCheckoutCaptureContextRequest.

        :return: The capture_mandate of this GenerateUnifiedCheckoutCaptureContextRequest.
        :rtype: Upv1capturecontextsCaptureMandate
        """
        return self._capture_mandate

    @capture_mandate.setter
    def capture_mandate(self, capture_mandate):
        """
        Sets the capture_mandate of this GenerateUnifiedCheckoutCaptureContextRequest.

        :param capture_mandate: The capture_mandate of this GenerateUnifiedCheckoutCaptureContextRequest.
        :type: Upv1capturecontextsCaptureMandate
        """

        self._capture_mandate = capture_mandate

    @property
    def complete_mandate(self):
        """
        Gets the complete_mandate of this GenerateUnifiedCheckoutCaptureContextRequest.

        :return: The complete_mandate of this GenerateUnifiedCheckoutCaptureContextRequest.
        :rtype: Upv1capturecontextsCompleteMandate
        """
        return self._complete_mandate

    @complete_mandate.setter
    def complete_mandate(self, complete_mandate):
        """
        Sets the complete_mandate of this GenerateUnifiedCheckoutCaptureContextRequest.

        :param complete_mandate: The complete_mandate of this GenerateUnifiedCheckoutCaptureContextRequest.
        :type: Upv1capturecontextsCompleteMandate
        """

        self._complete_mandate = complete_mandate

    @property
    def transient_token_response_options(self):
        """
        Gets the transient_token_response_options of this GenerateUnifiedCheckoutCaptureContextRequest.

        :return: The transient_token_response_options of this GenerateUnifiedCheckoutCaptureContextRequest.
        :rtype: Microformv2sessionsTransientTokenResponseOptions
        """
        return self._transient_token_response_options

    @transient_token_response_options.setter
    def transient_token_response_options(self, transient_token_response_options):
        """
        Sets the transient_token_response_options of this GenerateUnifiedCheckoutCaptureContextRequest.

        :param transient_token_response_options: The transient_token_response_options of this GenerateUnifiedCheckoutCaptureContextRequest.
        :type: Microformv2sessionsTransientTokenResponseOptions
        """

        self._transient_token_response_options = transient_token_response_options

    @property
    def data(self):
        """
        Gets the data of this GenerateUnifiedCheckoutCaptureContextRequest.

        :return: The data of this GenerateUnifiedCheckoutCaptureContextRequest.
        :rtype: Upv1capturecontextsData
        """
        return self._data

    @data.setter
    def data(self, data):
        """
        Sets the data of this GenerateUnifiedCheckoutCaptureContextRequest.

        :param data: The data of this GenerateUnifiedCheckoutCaptureContextRequest.
        :type: Upv1capturecontextsData
        """

        self._data = data

    @property
    def order_information(self):
        """
        Gets the order_information of this GenerateUnifiedCheckoutCaptureContextRequest.

        :return: The order_information of this GenerateUnifiedCheckoutCaptureContextRequest.
        :rtype: Upv1capturecontextsOrderInformation
        """
        return self._order_information

    @order_information.setter
    def order_information(self, order_information):
        """
        Sets the order_information of this GenerateUnifiedCheckoutCaptureContextRequest.

        :param order_information: The order_information of this GenerateUnifiedCheckoutCaptureContextRequest.
        :type: Upv1capturecontextsOrderInformation
        """

        self._order_information = order_information

    def to_dict(self):
        """
        Returns the model properties as a dict
        """
        result = {}

        for attr, _ in iteritems(self.swagger_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value

        return result

    def to_str(self):
        """
        Returns the string representation of the model
        """
        return pformat(self.to_dict())

    def __repr__(self):
        """
        For `print` and `pprint`
        """
        return self.to_str()

    def __eq__(self, other):
        """
        Returns true if both objects are equal
        """
        if not isinstance(other, GenerateUnifiedCheckoutCaptureContextRequest):
            return False

        return self.__dict__ == other.__dict__

    def __ne__(self, other):
        """
        Returns true if both objects are not equal
        """
        return not self == other
