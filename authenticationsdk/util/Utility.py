import json
import re
import os
from cryptography.hazmat.primitives import serialization
from cryptography.hazmat.primitives.serialization import pkcs12
from cryptography.hazmat.backends import default_backend
from cryptography.x509.oid import NameOID
from jwcrypto import jwk 

def get_response_code_message(response):
    switcher = {
        200: "Transaction Successful",
        400: "Bad Request",
        401: "Authentication Failed",
        403: "Forbidden",
        404: "URL Not Found",
        201: "Transaction Successful",
        500: "Internal Server Error",
        502:  "Bad Gateway",
        503: "SERVICE UNAVAILABLE",
        504: "Gateway Timeout"

    }
    return switcher.get(response, "Un-Identified")

def replace_underscore(dict_obj, deep=True):
    assert type(dict_obj) == dict
    converted_dict_obj = {}
    for snake_case_k in dict_obj:
        camel_case_k = re.sub('_([a-z])', lambda match: match.group(1).upper(), snake_case_k)
        value = dict_obj[snake_case_k]

        if type(value) == dict and deep:
            converted_dict_obj[camel_case_k] = replace_underscore(value, deep)
        elif type(value) == list and deep:
            converted_list_items = []
            for item in value:
                if type(item) == str:
                    converted_list_items.append(item)
                else:
                    converted_list_items.append(replace_underscore(item, deep))
            converted_dict_obj[camel_case_k] = converted_list_items
        else:
            converted_dict_obj[camel_case_k] = dict_obj[snake_case_k]
    return converted_dict_obj

def process_body(body):
    temp_body = body.replace("\"_", "\"")
    request_body = replace_underscore(json.loads(temp_body))
    body = json.dumps(request_body)
    body = body.replace("companyTaxId", "companyTaxID")
    body = body.replace("productSku", "productSKU")
    body = body.replace("secCode", "SECCode")
    return body

def to_jwk_private_key(private_key):
    """
    Ensure the provided private_key is a jwcrypto.jwk.JWK instance.
    Accepts a jwk.JWK or a cryptography private key object.
    """
    if private_key is None:
        raise ValueError("Private key is None")
    if isinstance(private_key, jwk.JWK):
        return private_key
    if hasattr(private_key, "private_bytes"):
        pem = private_key.private_bytes(
            serialization.Encoding.PEM,
            serialization.PrivateFormat.PKCS8,
            serialization.NoEncryption()
        )
        return jwk.JWK.from_pem(pem)
    raise ValueError("Unsupported private key type for JWK conversion")

def parse_p12_file(file_path, password, logger=None):
    """
    Parses a P12/PFX file and returns certificate list.
    
    Args:
        file_path (str): Path to the P12/PFX file
        password (str): Password for the P12 file
        logger: Logger instance for logging
        
    Returns:
        list: List of certificates from the P12 file
        
    Raises:
        FileNotFoundError: If file doesn't exist
        ValueError: If password is incorrect or file is invalid
    """
    if logger:
        logger.debug(f"Parsing P12 file: {file_path}")
    
    if not os.path.exists(file_path):
        error_msg = f"File not found: {file_path}"
        if logger:
            logger.error(error_msg)
        raise FileNotFoundError(error_msg)
    
    try:
        with open(file_path, 'rb') as f:
            p12_data = f.read()
        
        # Parse P12 file
        private_key, certificate, additional_certs = pkcs12.load_key_and_certificates(
            p12_data,
            password.encode() if isinstance(password, str) else password,
            backend=default_backend()
        )
        
        # Combine main certificate and additional certificates
        all_certs = []
        if certificate:
            all_certs.append(certificate)
        if additional_certs:
            all_certs.extend(additional_certs)
        
        if logger:
            logger.debug(f"Successfully parsed P12 file. Found {len(all_certs)} certificate(s)")
        
        return all_certs
    except Exception as e:
        error_msg = f"Error parsing P12 file: {file_path}: {str(e)}"
        if logger:
            logger.error(error_msg)
        raise ValueError(error_msg)

def is_cybersource_p12(file_path, password, logger=None):
    """
    Checks if a P12 file is generated by CyberSource.
    Validates that the P12 contains a certificate with CN="CyberSource_SJC_US".
    
    Args:
        file_path (str): Path to the P12 file
        password (str): Password for the P12 file
        logger: Logger instance for logging
        
    Returns:
        bool: True if the P12 file is generated by CyberSource, False otherwise
    """
    from authenticationsdk.util.GlobalLabelParameters import GlobalLabelParameters
    from authenticationsdk.util.Cache import FileCache
    
    try:
        if logger:
            logger.debug(f"Checking if P12 file is generated by CyberSource: {file_path}")
        
        # Parse P12 file using cache to avoid double parsing
        cache_obj = FileCache()
        certificates = cache_obj.fetch_cached_p12_from_file(file_path, password, logger)
        
        if not certificates:
            if logger:
                logger.debug("No certificates found in P12 file")
            return False
        
        if logger:
            logger.debug(f"Found {len(certificates)} certificate(s) in P12 file")
        
        # Check for CyberSource certificate
        for cert in certificates:
            try:
                # Get CN from certificate subject
                cn_attribute = cert.subject.get_attributes_for_oid(NameOID.COMMON_NAME)
                if cn_attribute:
                    cn = cn_attribute[0].value
                    if logger:
                        logger.debug(f"Found certificate with CN: {cn}")
                    
                    if cn == GlobalLabelParameters.DEFAULT_MLE_ALIAS_FOR_CERT:
                        if logger:
                            logger.debug(f"Found CyberSource certificate (CN={GlobalLabelParameters.DEFAULT_MLE_ALIAS_FOR_CERT})")
                        return True
            except Exception:
                continue
        
        if logger:
            logger.debug(f"P12 file does not contain CyberSource certificate (CN={GlobalLabelParameters.DEFAULT_MLE_ALIAS_FOR_CERT})")
        return False
        
    except Exception as e:
        if logger:
            logger.error(f"Error checking if P12 file is generated by CyberSource: {str(e)}")
        return False
